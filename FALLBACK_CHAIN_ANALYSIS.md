# Fallback 链异常分析报告

## 📊 数据概览

- **查询时间范围**: 2025-12-29 至 2025-12-29
- **总消耗积分**: 168,708
- **请求次数**: 839
- **平均每次请求消耗积分**: 201 积分/次

## 🔍 问题诊断

### 1. Fallback 链导致重复消耗积分 ⚠️⚠️⚠️

**核心问题**：Fallback 链会导致同一个批次多次调用 API，每次都会消耗积分。

**触发流程**：
1. **Level 1 (gemini-2.5-flash)** 调用成功 → 消耗 **60-70 积分**
2. 质量检查失败 → 触发 **Level 2 (gemini-3-flash)** → 再次消耗 **100-120 积分**
3. 如果 Level 2 也失败 → 触发 **Level 3 (gemini-3-pro)** → 再次消耗 **140-160 积分**

**实际消耗**：
- 纯 2.5-flash：60 积分
- 2.5-flash + 3-flash：170 积分（60 + 110）
- 2.5-flash + 3-flash + 3-pro：320 积分（60 + 110 + 150）

**当前平均 201 积分/次**，说明：
- 大部分请求都触发了 Fallback（从 2.5-flash 到 3-flash）
- 估算 Fallback 触发比例：**~70%**

### 2. 质量检查阈值过于严格 ⚠️⚠️

**位置**：`app/api/admin/batch-generation/process/check-generation-quality.ts`

**当前阈值**：
1. **数量不足**：`scenes.length < expectedCount * 0.5`（少于 50% 就触发）
2. **空内容**：有任何空内容就触发
3. **重复内容**：`duplicateCount > scenes.length * 0.3`（超过 30% 重复就触发）
4. **内容过短**：`shortScenes.length > scenes.length * 0.2`（超过 20% 过短就触发）

**问题**：
- 如果一批生成 50 条，但只生成了 24 条（49%），就会触发 Fallback
- 如果有 15 条重复（30%），就会触发 Fallback
- 如果有 10 条内容过短（20%），就会触发 Fallback

**这些阈值可能导致**：
- 即使内容可用，也会触发 Fallback
- 重复消耗积分（60 + 110 = 170 积分）
- 如果质量检查过于严格，可能导致大量不必要的 Fallback

### 3. 重试机制（已优化）✅

**位置**：`lib/grsai/client.ts`

**当前实现**：
- 网络错误时最多重试 3 次
- 但重试只在网络错误时，不会重复消耗积分（因为请求失败）

**结论**：重试机制不是问题，不会导致"干烧"。

### 4. 已实现的保护机制 ✅

1. **保存失败率检查**：如果保存失败率 > 50%，立即停止生成
2. **任务停止检查**：如果任务已停止/取消，立即停止生成
3. **内容过滤检查**：如果内容被过滤，不重试（避免浪费积分）

## 💡 优化建议

### 1. 放宽质量检查阈值（高优先级）⭐⭐⭐

**建议修改**：

```typescript
// 当前：scenes.length < expectedCount * 0.5
// 建议：scenes.length < expectedCount * 0.3（少于 30% 才触发）

// 当前：duplicateCount > scenes.length * 0.3
// 建议：duplicateCount > scenes.length * 0.5（超过 50% 重复才触发）

// 当前：shortScenes.length > scenes.length * 0.2
// 建议：shortScenes.length > scenes.length * 0.4（超过 40% 过短才触发）
```

**效果**：
- 减少不必要的 Fallback
- 降低平均积分消耗（从 201 降到 ~150）
- 节省约 **25-30%** 的积分消耗

### 2. 优化 Fallback 触发条件（高优先级）⭐⭐⭐

**建议**：
- **只在真正失败时触发 Fallback**（空数组、完全无法解析）
- **不要因为质量稍差就触发 Fallback**（可以接受部分质量不高的内容）
- **优先使用已生成的内容**，即使质量不是最优

**代码修改**：
```typescript
// 只在以下情况触发 Fallback：
// 1. 空数组（scenes.length === 0）
// 2. 数量极少（scenes.length < expectedCount * 0.2）
// 3. 完全无法解析（JSON 解析失败）
// 4. 检测到错误响应（"No data", "Not found" 等）

// 不要因为以下情况触发 Fallback：
// 1. 数量稍少（但 >= 30%）
// 2. 部分重复（但 < 50%）
// 3. 部分内容过短（但 < 40%）
```

### 3. 添加积分消耗监控（中优先级）⭐⭐

**建议**：
- 在数据库中记录每次 API 调用的模型和积分消耗
- 实时监控平均积分消耗
- 如果平均消耗超过阈值（如 180 积分/次），自动告警

### 4. 优化模型选择策略（中优先级）⭐⭐

**建议**：
- 对于已知的冷门行业，直接使用 3-flash，跳过 2.5-flash
- 避免先调用 2.5-flash 再 fallback 到 3-flash
- 根据历史数据，智能选择初始模型

## 📈 预期效果

### 优化前
- 平均积分消耗：**201 积分/次**
- Fallback 触发比例：**~70%**
- 总消耗：**168,708 积分**（839 次请求）

### 优化后（预期）
- 平均积分消耗：**~120 积分/次**（降低 40%）
- Fallback 触发比例：**~30%**（降低 40%）
- 总消耗：**~100,680 积分**（节省约 68,028 积分，约 40%）

## 🔧 立即行动项

1. **修改质量检查阈值**（`check-generation-quality.ts`）
   - 数量不足阈值：50% → 30%
   - 重复内容阈值：30% → 50%
   - 内容过短阈值：20% → 40%

2. **优化 Fallback 触发逻辑**
   - 只在真正失败时触发
   - 不要因为质量稍差就触发

3. **添加监控和告警**
   - 记录每次 API 调用的模型和积分
   - 实时监控平均积分消耗
   - 超过阈值时自动告警

## 📝 结论

**主要问题**：质量检查阈值过于严格，导致大量不必要的 Fallback，从而"干烧"积分。

**解决方案**：放宽质量检查阈值，只在真正失败时触发 Fallback。

**预期效果**：节省约 40% 的积分消耗。

