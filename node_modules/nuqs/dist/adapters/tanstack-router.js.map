{"version":3,"file":"tanstack-router.js","names":["search","NuqsAdapter: AdapterProvider"],"sources":["../../src/adapters/tanstack-router.ts"],"sourcesContent":["import { useLocation, useNavigate } from '@tanstack/react-router'\nimport { startTransition, useCallback, useMemo } from 'react'\nimport { renderQueryString } from '../lib/url-encoding'\nimport { createAdapterProvider, type AdapterProvider } from './lib/context'\nimport type { AdapterInterface, UpdateUrlFunction } from './lib/defs'\n\nfunction useNuqsTanstackRouterAdapter(watchKeys: string[]): AdapterInterface {\n  const pathname = useLocation({ select: state => state.pathname })\n  const search = useLocation({\n    select: state =>\n      Object.fromEntries(\n        Object.entries(state.search).filter(([key]) => watchKeys.includes(key))\n      )\n  })\n  const navigate = useNavigate()\n  const searchParams = useMemo(\n    () =>\n      // search is a Record<string, string | number | object | Array<string | number>>,\n      // so we need to flatten it into a list of key/value pairs,\n      // replicating keys that have multiple values before passing it\n      // to URLSearchParams, otherwise { foo: ['bar', 'baz'] }\n      // ends up as { foo → 'bar,baz' } instead of { foo → 'bar', foo → 'baz' }\n      new URLSearchParams(\n        Object.entries(search).flatMap(([key, value]) => {\n          if (Array.isArray(value)) {\n            return value.map(v => [key, v])\n          } else if (typeof value === 'object' && value !== null) {\n            // TSR JSON.parses objects in the search params,\n            // but parseAsJson expects a JSON string,\n            // so we need to re-stringify it first.\n            return [[key, JSON.stringify(value)]]\n          } else {\n            return [[key, value]]\n          }\n        })\n      ),\n    [search, watchKeys.join(',')]\n  )\n\n  const updateUrl: UpdateUrlFunction = useCallback(\n    (search, options) => {\n      // Wrapping in a startTransition seems to be necessary\n      // to support scroll restoration\n      startTransition(() => {\n        navigate({\n          // I know the docs say to use `search` here, but it would require\n          // userland code to stitch the nuqs definitions to the route declarations\n          // in order for TSR to serialize them, which kind of breaks the\n          // \"works out of the box\" promise, and it also wouldn't support\n          // the custom URL encoding.\n          // TBC if it causes issues with consuming those search params\n          // in other parts of the app.\n          //\n          // Note: we need to specify pathname + search here to avoid TSR appending\n          // a trailing slash to the pathname, see https://github.com/47ng/nuqs/issues/1215\n          from: '/',\n          to: pathname + renderQueryString(search),\n          replace: options.history === 'replace',\n          resetScroll: options.scroll,\n          hash: prevHash => prevHash ?? '',\n          state: state => state\n        })\n      })\n    },\n    [navigate, pathname]\n  )\n\n  return {\n    searchParams,\n    updateUrl,\n    rateLimitFactor: 1\n  }\n}\n\nexport const NuqsAdapter: AdapterProvider = createAdapterProvider(\n  useNuqsTanstackRouterAdapter\n)\n"],"mappings":";;;;;;;AAMA,SAAS,6BAA6B,WAAuC;CAC3E,MAAM,WAAW,YAAY,EAAE,SAAQ,UAAS,MAAM,UAAU,CAAC;CACjE,MAAM,SAAS,YAAY,EACzB,SAAQ,UACN,OAAO,YACL,OAAO,QAAQ,MAAM,OAAO,CAAC,QAAQ,CAAC,SAAS,UAAU,SAAS,IAAI,CAAC,CACxE,EACJ,CAAC;CACF,MAAM,WAAW,aAAa;AAqD9B,QAAO;EACL,cArDmB,cAOjB,IAAI,gBACF,OAAO,QAAQ,OAAO,CAAC,SAAS,CAAC,KAAK,WAAW;AAC/C,OAAI,MAAM,QAAQ,MAAM,CACtB,QAAO,MAAM,KAAI,MAAK,CAAC,KAAK,EAAE,CAAC;YACtB,OAAO,UAAU,YAAY,UAAU,KAIhD,QAAO,CAAC,CAAC,KAAK,KAAK,UAAU,MAAM,CAAC,CAAC;OAErC,QAAO,CAAC,CAAC,KAAK,MAAM,CAAC;IAEvB,CACH,EACH,CAAC,QAAQ,UAAU,KAAK,IAAI,CAAC,CAC9B;EAgCC,WA9BmC,aAClC,UAAQ,YAAY;AAGnB,yBAAsB;AACpB,aAAS;KAWP,MAAM;KACN,IAAI,WAAW,kBAAkBA,SAAO;KACxC,SAAS,QAAQ,YAAY;KAC7B,aAAa,QAAQ;KACrB,OAAM,aAAY,YAAY;KAC9B,QAAO,UAAS;KACjB,CAAC;KACF;KAEJ,CAAC,UAAU,SAAS,CACrB;EAKC,iBAAiB;EAClB;;AAGH,MAAaC,cAA+B,sBAC1C,6BACD"}