"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = workflowLoader;
const node_path_1 = require("node:path");
const core_1 = require("@swc/core");
// This loader applies the "use workflow"/"use step"
// client transformation
async function workflowLoader(source, sourceMap) {
    const filename = this.resourcePath;
    const normalizedSource = source.toString();
    // only apply the transform if file needs it
    if (!normalizedSource.match(/(use step|use workflow)/)) {
        return normalizedSource;
    }
    const isTypeScript = filename.endsWith('.ts') ||
        filename.endsWith('.tsx') ||
        filename.endsWith('.mts') ||
        filename.endsWith('.cts');
    // Calculate relative filename for SWC plugin
    // The SWC plugin uses filename to generate workflowId, so it must be relative
    const workingDir = process.cwd();
    const normalizedWorkingDir = workingDir
        .replace(/\\/g, '/')
        .replace(/\/$/, '');
    const normalizedFilepath = filename.replace(/\\/g, '/');
    // Windows fix: Use case-insensitive comparison to work around drive letter casing issues
    const lowerWd = normalizedWorkingDir.toLowerCase();
    const lowerPath = normalizedFilepath.toLowerCase();
    let relativeFilename;
    if (lowerPath.startsWith(lowerWd + '/')) {
        // File is under working directory - manually calculate relative path
        relativeFilename = normalizedFilepath.substring(normalizedWorkingDir.length + 1);
    }
    else if (lowerPath === lowerWd) {
        // File IS the working directory (shouldn't happen)
        relativeFilename = '.';
    }
    else {
        // Use relative() for files outside working directory
        relativeFilename = (0, node_path_1.relative)(workingDir, filename).replace(/\\/g, '/');
        if (relativeFilename.startsWith('../')) {
            relativeFilename = relativeFilename
                .split('/')
                .filter((part) => part !== '..')
                .join('/');
        }
    }
    // Final safety check - ensure we never pass an absolute path to SWC
    if (relativeFilename.includes(':') || relativeFilename.startsWith('/')) {
        // This should rarely happen, but use filename split as last resort
        relativeFilename = normalizedFilepath.split('/').pop() || 'unknown.ts';
    }
    // Transform with SWC
    const result = await (0, core_1.transform)(normalizedSource, {
        filename: relativeFilename,
        jsc: {
            parser: {
                ...(isTypeScript
                    ? {
                        syntax: 'typescript',
                        tsx: filename.endsWith('.tsx'),
                    }
                    : {
                        syntax: 'ecmascript',
                        jsx: filename.endsWith('.jsx'),
                    }),
            },
            target: 'es2022',
            experimental: {
                plugins: [
                    [require.resolve('@workflow/swc-plugin'), { mode: 'client' }],
                ],
            },
            transform: {
                react: {
                    runtime: 'preserve',
                },
            },
        },
        minify: false,
        inputSourceMap: sourceMap,
        sourceMaps: true,
        inlineSourcesContent: true,
    });
    return result.code;
}
//# sourceMappingURL=loader.js.map