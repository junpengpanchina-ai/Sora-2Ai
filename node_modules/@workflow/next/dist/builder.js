"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextBuilder = getNextBuilder;
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const watchpack_1 = __importDefault(require("watchpack"));
let CachedNextBuilder;
// Create the NextBuilder class dynamically by extending the ESM BaseBuilder
// This is exported as getNextBuilder() to allow CommonJS modules to import
// from the ESM @workflow/builders package via dynamic import at runtime
async function getNextBuilder() {
    if (CachedNextBuilder) {
        return CachedNextBuilder;
    }
    const { BaseBuilder: BaseBuilderClass, STEP_QUEUE_TRIGGER, WORKFLOW_QUEUE_TRIGGER,
    // biome-ignore lint/security/noGlobalEval: Need to use eval here to avoid TypeScript from transpiling the import statement into `require()`
     } = (await eval('import("@workflow/builders")'));
    class NextBuilder extends BaseBuilderClass {
        async build() {
            const outputDir = await this.findAppDirectory();
            const workflowGeneratedDir = (0, node_path_1.join)(outputDir, '.well-known/workflow/v1');
            // Ensure output directories exist
            await (0, promises_1.mkdir)(workflowGeneratedDir, { recursive: true });
            // ignore the generated assets
            await (0, promises_1.writeFile)((0, node_path_1.join)(workflowGeneratedDir, '.gitignore'), '*');
            const inputFiles = await this.getInputFiles();
            const tsConfig = await this.getTsConfigOptions();
            const options = {
                inputFiles,
                workflowGeneratedDir,
                tsBaseUrl: tsConfig.baseUrl,
                tsPaths: tsConfig.paths,
            };
            const stepsBuildContext = await this.buildStepsFunction(options);
            const workflowsBundle = await this.buildWorkflowsFunction(options);
            await this.buildWebhookRoute({ workflowGeneratedDir });
            await this.writeFunctionsConfig(outputDir);
            if (this.config.watch) {
                if (!stepsBuildContext) {
                    throw new Error('Invariant: expected steps build context in watch mode');
                }
                if (!workflowsBundle) {
                    throw new Error('Invariant: expected workflows bundle in watch mode');
                }
                let stepsCtx = stepsBuildContext;
                let workflowsCtx = workflowsBundle;
                const normalizePath = (pathname) => pathname.replace(/\\/g, '/');
                const knownFiles = new Set();
                let previousTimeInfo = new Map();
                const watchableExtensions = new Set([
                    '.js',
                    '.jsx',
                    '.ts',
                    '.tsx',
                    '.mts',
                    '.cts',
                    '.cjs',
                    '.mjs',
                ]);
                const ignoredPathFragments = [
                    '/.git/',
                    '/node_modules/',
                    '/.next/',
                    '/.turbo/',
                    '/.vercel/',
                    '/dist/',
                    '/build/',
                    '/out/',
                    '/.cache/',
                    '/.yarn/',
                    '/.pnpm-store/',
                    '/.parcel-cache/',
                    '/.well-known/workflow/',
                ];
                const normalizedGeneratedDir = workflowGeneratedDir.replace(/\\/g, '/');
                ignoredPathFragments.push(normalizedGeneratedDir);
                // There is a node.js bug on MacOS which causes closing file watchers to be really slow.
                // This limits the number of watchers to mitigate the issue.
                // https://github.com/nodejs/node/issues/29949
                process.env.WATCHPACK_WATCHER_LIMIT =
                    process.platform === 'darwin' ? '20' : undefined;
                const watcher = new watchpack_1.default({
                    // Watchpack default is 200ms which adds 200ms of dead time on bootup.
                    aggregateTimeout: 5,
                    ignored: (pathname) => {
                        const normalizedPath = pathname.replace(/\\/g, '/');
                        const extension = (0, node_path_1.extname)(normalizedPath);
                        if (extension && !watchableExtensions.has(extension)) {
                            return true;
                        }
                        if (normalizedPath.startsWith(normalizedGeneratedDir)) {
                            return true;
                        }
                        for (const fragment of ignoredPathFragments) {
                            if (normalizedPath.includes(fragment)) {
                                return true;
                            }
                        }
                        return false;
                    },
                });
                const readTimeInfoEntries = () => {
                    const rawEntries = watcher.getTimeInfoEntries();
                    const normalizedEntries = new Map();
                    for (const [path, info] of rawEntries) {
                        normalizedEntries.set(normalizePath(path), info);
                    }
                    return normalizedEntries;
                };
                let rebuildQueue = Promise.resolve();
                const enqueue = (task) => {
                    rebuildQueue = rebuildQueue.then(task).catch((error) => {
                        console.error('Failed to process file change', error);
                    });
                    return rebuildQueue;
                };
                const fullRebuild = async () => {
                    const newInputFiles = await this.getInputFiles();
                    options.inputFiles = newInputFiles;
                    await stepsCtx.dispose();
                    const newStepsCtx = await this.buildStepsFunction(options);
                    if (!newStepsCtx) {
                        throw new Error('Invariant: expected steps build context after rebuild');
                    }
                    stepsCtx = newStepsCtx;
                    await workflowsCtx.interimBundleCtx.dispose();
                    const newWorkflowsCtx = await this.buildWorkflowsFunction(options);
                    if (!newWorkflowsCtx) {
                        throw new Error('Invariant: expected workflows bundle context after rebuild');
                    }
                    workflowsCtx = newWorkflowsCtx;
                };
                const logBuildMessages = (result, label) => {
                    const logByType = (messages, method) => {
                        if (!messages || messages.length === 0) {
                            return;
                        }
                        const descriptor = method === 'error' ? 'errors' : 'warnings';
                        console[method](`${descriptor} while rebuilding ${label}`);
                        for (const message of messages) {
                            console[method](message);
                        }
                    };
                    logByType(result.errors, 'error');
                    logByType(result.warnings, 'warn');
                };
                const rebuildExistingFiles = async () => {
                    const rebuiltStepStart = Date.now();
                    const stepsResult = await stepsCtx.rebuild();
                    logBuildMessages(stepsResult, 'steps bundle');
                    console.log('Rebuilt steps bundle', `${Date.now() - rebuiltStepStart}ms`);
                    const rebuiltWorkflowStart = Date.now();
                    const workflowResult = await workflowsCtx.interimBundleCtx.rebuild();
                    logBuildMessages(workflowResult, 'workflows bundle');
                    if (!workflowResult.outputFiles ||
                        workflowResult.outputFiles.length === 0) {
                        console.error('No output generated while rebuilding workflows bundle');
                        return;
                    }
                    await workflowsCtx.bundleFinal(workflowResult.outputFiles[0].text);
                    console.log('Rebuilt workflow bundle', `${Date.now() - rebuiltWorkflowStart}ms`);
                };
                const isWatchableFile = (path) => watchableExtensions.has((0, node_path_1.extname)(path));
                const getComparableTimestamp = (entry) => entry.timestamp ?? entry.safeTime;
                const findRemovedFiles = (currentEntries, previousEntries) => {
                    const removed = [];
                    for (const path of previousEntries.keys()) {
                        if (!currentEntries.has(path) && isWatchableFile(path)) {
                            removed.push(path);
                        }
                    }
                    return removed;
                };
                const findAddedAndModifiedFiles = (currentEntries, previousEntries) => {
                    const added = [];
                    const modified = [];
                    for (const [path, info] of currentEntries) {
                        if (!isWatchableFile(path)) {
                            continue;
                        }
                        const previous = previousEntries.get(path);
                        if (!previous) {
                            added.push(path);
                            continue;
                        }
                        if (getComparableTimestamp(info) !== getComparableTimestamp(previous)) {
                            modified.push(path);
                        }
                    }
                    return { added, modified };
                };
                const determineFileChanges = (currentEntries, previousEntries) => {
                    const removedFiles = findRemovedFiles(currentEntries, previousEntries);
                    const { added, modified } = findAddedAndModifiedFiles(currentEntries, previousEntries);
                    return {
                        addedFiles: added,
                        modifiedFiles: modified,
                        removedFiles,
                    };
                };
                let isInitial = true;
                watcher.on('aggregated', () => {
                    const currentEntries = readTimeInfoEntries();
                    const { addedFiles, modifiedFiles, removedFiles } = determineFileChanges(currentEntries, previousTimeInfo);
                    previousTimeInfo = currentEntries;
                    if (isInitial) {
                        isInitial = false;
                        return;
                    }
                    if (addedFiles.length === 0 &&
                        modifiedFiles.length === 0 &&
                        removedFiles.length === 0) {
                        return;
                    }
                    for (const removal of removedFiles) {
                        knownFiles.delete(removal);
                    }
                    for (const added of addedFiles) {
                        knownFiles.add(added);
                    }
                    enqueue(async () => {
                        if (addedFiles.length > 0 || removedFiles.length > 0) {
                            await fullRebuild();
                            return;
                        }
                        if (modifiedFiles.length > 0) {
                            await rebuildExistingFiles();
                        }
                    });
                });
                watcher.watch({
                    directories: [this.config.workingDir],
                    startTime: 0,
                });
            }
        }
        async getInputFiles() {
            const inputFiles = await super.getInputFiles();
            return inputFiles.filter((item) => 
            // non-exact pattern match to try to narrow
            // down to just app route entrypoints, this will
            // not be valid when pages router support is added
            item.match(/[/\\](route|page|layout)\./));
        }
        async writeFunctionsConfig(outputDir) {
            // we don't run this in development mode as it's not needed
            if (process.env.NODE_ENV === 'development') {
                return;
            }
            const generatedConfig = {
                version: '0',
                steps: {
                    experimentalTriggers: [STEP_QUEUE_TRIGGER],
                },
                workflows: {
                    experimentalTriggers: [WORKFLOW_QUEUE_TRIGGER],
                },
            };
            // We write this file to the generated directory for
            // the Next.js builder to consume
            await (0, promises_1.writeFile)((0, node_path_1.join)(outputDir, '.well-known/workflow/v1/config.json'), JSON.stringify(generatedConfig, null, 2));
        }
        async buildStepsFunction({ inputFiles, workflowGeneratedDir, tsPaths, tsBaseUrl, }) {
            // Create steps bundle
            const stepsRouteDir = (0, node_path_1.join)(workflowGeneratedDir, 'step');
            await (0, promises_1.mkdir)(stepsRouteDir, { recursive: true });
            return await this.createStepsBundle({
                // If any dynamic requires are used when bundling with ESM
                // esbuild will create a too dynamic wrapper around require
                // which turbopack/webpack fail to analyze. If we externalize
                // correctly this shouldn't be an issue although we might want
                // to use cjs as alternative to avoid
                format: 'esm',
                inputFiles,
                outfile: (0, node_path_1.join)(stepsRouteDir, 'route.js'),
                externalizeNonSteps: true,
                tsBaseUrl,
                tsPaths,
            });
        }
        async buildWorkflowsFunction({ inputFiles, workflowGeneratedDir, tsPaths, tsBaseUrl, }) {
            const workflowsRouteDir = (0, node_path_1.join)(workflowGeneratedDir, 'flow');
            await (0, promises_1.mkdir)(workflowsRouteDir, { recursive: true });
            return await this.createWorkflowsBundle({
                format: 'esm',
                outfile: (0, node_path_1.join)(workflowsRouteDir, 'route.js'),
                bundleFinalOutput: false,
                inputFiles,
                tsBaseUrl,
                tsPaths,
            });
        }
        async buildWebhookRoute({ workflowGeneratedDir, }) {
            const webhookRouteFile = (0, node_path_1.join)(workflowGeneratedDir, 'webhook/[token]/route.js');
            await this.createWebhookBundle({
                outfile: webhookRouteFile,
                bundle: false, // Next.js doesn't need bundling
            });
        }
        async findAppDirectory() {
            const appDir = (0, node_path_1.resolve)(this.config.workingDir, 'app');
            const srcAppDir = (0, node_path_1.resolve)(this.config.workingDir, 'src/app');
            try {
                await (0, promises_1.access)(appDir, node_fs_1.constants.F_OK);
                const appStats = await (0, promises_1.stat)(appDir);
                if (!appStats.isDirectory()) {
                    throw new Error(`Path exists but is not a directory: ${appDir}`);
                }
                return appDir;
            }
            catch {
                try {
                    await (0, promises_1.access)(srcAppDir, node_fs_1.constants.F_OK);
                    const srcAppStats = await (0, promises_1.stat)(srcAppDir);
                    if (!srcAppStats.isDirectory()) {
                        throw new Error(`Path exists but is not a directory: ${srcAppDir}`);
                    }
                    return srcAppDir;
                }
                catch {
                    throw new Error('Could not find Next.js app directory. Expected either "app" or "src/app" to exist.');
                }
            }
        }
    }
    CachedNextBuilder = NextBuilder;
    return NextBuilder;
}
//# sourceMappingURL=builder.js.map