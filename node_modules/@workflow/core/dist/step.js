import { FatalError, WorkflowRuntimeError } from '@workflow/errors';
import { withResolvers } from '@workflow/utils';
import { EventConsumerResult } from './events-consumer.js';
import { WorkflowSuspension } from './global.js';
import { stepLogger } from './logger.js';
import { hydrateStepReturnValue } from './serialization.js';
export function createUseStep(ctx) {
    return function useStep(stepName, closureVarsFn) {
        const stepFunction = (...args) => {
            const { promise, resolve, reject } = withResolvers();
            const correlationId = `step_${ctx.generateUlid()}`;
            const queueItem = {
                type: 'step',
                correlationId,
                stepName,
                args,
            };
            // Invoke the closure variables function to get the closure scope
            const closureVars = closureVarsFn?.();
            if (closureVars) {
                queueItem.closureVars = closureVars;
            }
            ctx.invocationsQueue.set(correlationId, queueItem);
            // Track whether we've already seen a "step_started" event for this step.
            // This is important because after a retryable failure, the step moves back to
            // "pending" status which causes another "step_started" event to be emitted.
            let hasSeenStepStarted = false;
            stepLogger.debug('Step consumer setup', {
                correlationId,
                stepName,
                args,
            });
            ctx.eventsConsumer.subscribe((event) => {
                if (!event) {
                    // We've reached the end of the events, so this step has either not been run or is currently running.
                    // Crucially, if we got here, then this step Promise does
                    // not resolve so that the user workflow code does not proceed any further.
                    // Notify the workflow handler that this step has not been run / has not completed yet.
                    setTimeout(() => {
                        ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
                    }, 0);
                    return EventConsumerResult.NotConsumed;
                }
                stepLogger.debug('Step consumer event processing', {
                    correlationId,
                    stepName,
                    args: args.join(', '),
                    incomingCorrelationId: event.correlationId,
                    isMatch: correlationId === event.correlationId,
                    eventType: event.eventType,
                });
                if (event.correlationId !== correlationId) {
                    // We're not interested in this event - the correlationId belongs to a different step
                    return EventConsumerResult.NotConsumed;
                }
                if (event.eventType === 'step_started') {
                    // Step has started - so remove from the invocations queue (only on the first "step_started" event)
                    if (!hasSeenStepStarted) {
                        // O(1) lookup and delete using Map
                        if (ctx.invocationsQueue.has(correlationId)) {
                            ctx.invocationsQueue.delete(correlationId);
                        }
                        else {
                            setTimeout(() => {
                                reject(new WorkflowRuntimeError(`Corrupted event log: step ${correlationId} (${stepName}) started but not found in invocation queue`));
                            }, 0);
                            return EventConsumerResult.Finished;
                        }
                        hasSeenStepStarted = true;
                    }
                    // If this is a subsequent "step_started" event (after a retry), we just consume it
                    // without trying to remove from the queue again or logging a warning
                    return EventConsumerResult.Consumed;
                }
                if (event.eventType === 'step_failed') {
                    // Step failed - bubble up to workflow
                    if (event.eventData.fatal) {
                        setTimeout(() => {
                            reject(new FatalError(event.eventData.error));
                        }, 0);
                        return EventConsumerResult.Finished;
                    }
                    else {
                        // This is a retryable error, so nothing to do here,
                        // but we will consume the event
                        return EventConsumerResult.Consumed;
                    }
                }
                else if (event.eventType === 'step_completed') {
                    // Step has already completed, so resolve the Promise with the cached result
                    const hydratedResult = hydrateStepReturnValue(event.eventData.result, ctx.globalThis);
                    setTimeout(() => {
                        resolve(hydratedResult);
                    }, 0);
                    return EventConsumerResult.Finished;
                }
                else {
                    // An unexpected event type has been received, but it does belong to this step (matching `correlationId`)
                    setTimeout(() => {
                        reject(new WorkflowRuntimeError(`Unexpected event type: "${event.eventType}"`));
                    }, 0);
                    return EventConsumerResult.Finished;
                }
            });
            return promise;
        };
        // Ensure the "name" property matches the original step function name
        // Extract function name from stepName (format: "step//filepath//functionName")
        const functionName = stepName.split('//').pop();
        Object.defineProperty(stepFunction, 'name', {
            value: functionName,
        });
        // Add the step function identifier to the step function for serialization
        Object.defineProperty(stepFunction, 'stepId', {
            value: stepName,
            writable: false,
            enumerable: false,
            configurable: false,
        });
        // Store the closure variables function for serialization
        if (closureVarsFn) {
            Object.defineProperty(stepFunction, '__closureVarsFn', {
                value: closureVarsFn,
                writable: false,
                enumerable: false,
                configurable: false,
            });
        }
        return stepFunction;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zdGVwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFnQyxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUMvRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBR3pDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRTVELE1BQU0sVUFBVSxhQUFhLENBQUMsR0FBZ0M7SUFDNUQsT0FBTyxTQUFTLE9BQU8sQ0FDckIsUUFBZ0IsRUFDaEIsYUFBa0Q7UUFFbEQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxHQUFHLElBQVUsRUFBbUIsRUFBRTtZQUN0RCxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxhQUFhLEVBQVUsQ0FBQztZQUU3RCxNQUFNLGFBQWEsR0FBRyxRQUFRLEdBQUcsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDO1lBRW5ELE1BQU0sU0FBUyxHQUE0QjtnQkFDekMsSUFBSSxFQUFFLE1BQU07Z0JBQ1osYUFBYTtnQkFDYixRQUFRO2dCQUNSLElBQUk7YUFDTCxDQUFDO1lBRUYsaUVBQWlFO1lBQ2pFLE1BQU0sV0FBVyxHQUFHLGFBQWEsRUFBRSxFQUFFLENBQUM7WUFDdEMsSUFBSSxXQUFXLEVBQUUsQ0FBQztnQkFDaEIsU0FBUyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7WUFDdEMsQ0FBQztZQUVELEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRW5ELHlF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