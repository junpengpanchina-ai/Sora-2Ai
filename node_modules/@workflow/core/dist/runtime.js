import { WorkflowRunCancelledError, WorkflowRunFailedError, WorkflowRunNotCompletedError, } from '@workflow/errors';
import { WorkflowInvokePayloadSchema, } from '@workflow/world';
import { WorkflowSuspension } from './global.js';
import { runtimeLogger } from './logger.js';
import { parseWorkflowName } from './parse-name.js';
import { getAllWorkflowRunEvents, getQueueOverhead, withHealthCheck, } from './runtime/helpers.js';
import { handleSuspension } from './runtime/suspension-handler.js';
import { getWorld, getWorldHandlers } from './runtime/world.js';
import { getExternalRevivers, hydrateWorkflowReturnValue, } from './serialization.js';
import { remapErrorStack } from './source-map.js';
import * as Attribute from './telemetry/semantic-conventions.js';
import { linkToCurrentContext, trace, withTraceContext } from './telemetry.js';
import { getErrorName, getErrorStack } from './types.js';
import { buildWorkflowSuspensionMessage, getWorkflowRunStreamId, } from './util.js';
import { runWorkflow } from './workflow.js';
export { WorkflowSuspension } from './global.js';
export { getHookByToken, resumeHook, resumeWebhook, } from './runtime/resume-hook.js';
export { start } from './runtime/start.js';
export { createWorld, getWorld, getWorldHandlers, setWorld, } from './runtime/world.js';
export { stepEntrypoint } from './runtime/step-handler.js';
/**
 * A handler class for a workflow run.
 */
export class Run {
    /**
     * The ID of the workflow run.
     */
    runId;
    /**
     * The world object.
     * @internal
     */
    world;
    constructor(runId) {
        this.runId = runId;
        this.world = getWorld();
    }
    /**
     * Cancels the workflow run.
     */
    async cancel() {
        await this.world.runs.cancel(this.runId);
    }
    /**
     * The status of the workflow run.
     */
    get status() {
        return this.world.runs.get(this.runId).then((run) => run.status);
    }
    /**
     * The return value of the workflow run.
     * Polls the workflow return value until it is completed.
     */
    get returnValue() {
        return this.pollReturnValue();
    }
    /**
     * The name of the workflow.
     */
    get workflowName() {
        return this.world.runs.get(this.runId).then((run) => run.workflowName);
    }
    /**
     * The timestamp when the workflow run was created.
     */
    get createdAt() {
        return this.world.runs.get(this.runId).then((run) => run.createdAt);
    }
    /**
     * The timestamp when the workflow run started execution.
     * Returns undefined if the workflow has not started yet.
     */
    get startedAt() {
        return this.world.runs.get(this.runId).then((run) => run.startedAt);
    }
    /**
     * The timestamp when the workflow run completed.
     * Returns undefined if the workflow has not completed yet.
     */
    get completedAt() {
        return this.world.runs.get(this.runId).then((run) => run.completedAt);
    }
    /**
     * The readable stream of the workflow run.
     */
    get readable() {
        return this.getReadable();
    }
    /**
     * Retrieves the workflow run's default readable stream, which reads chunks
     * written to the corresponding writable stream {@link getWritable}.
     *
     * @param options - The options for the readable stream.
     * @returns The `ReadableStream` for the workflow run.
     */
    getReadable(options = {}) {
        const { ops = [], global = globalThis, startIndex, namespace } = options;
        const name = getWorkflowRunStreamId(this.runId, namespace);
        return getExternalRevivers(global, ops, this.runId).ReadableStream({
            name,
            startIndex,
        });
    }
    /**
     * Polls the workflow return value every 1 second until it is completed.
     * @internal
     * @returns The workflow return value.
     */
    async pollReturnValue() {
        while (true) {
            try {
                const run = await this.world.runs.get(this.runId);
                if (run.status === 'completed') {
                    return hydrateWorkflowReturnValue(run.output, [], this.runId);
                }
                if (run.status === 'cancelled') {
                    throw new WorkflowRunCancelledError(this.runId);
                }
                if (run.status === 'failed') {
                    throw new WorkflowRunFailedError(this.runId, run.error);
                }
                throw new WorkflowRunNotCompletedError(this.runId, run.status);
            }
            catch (error) {
                if (WorkflowRunNotCompletedError.is(error)) {
                    await new Promise((resolve) => setTimeout(resolve, 1_000));
                    continue;
                }
                throw error;
            }
        }
    }
}
/**
 * Retrieves a `Run` object for a given run ID.
 *
 * @param runId - The workflow run ID obtained from {@link start}.
 * @returns A `Run` object.
 * @throws WorkflowRunNotFoundError if the run ID is not found.
 */
export function getRun(runId) {
    return new Run(runId);
}
/**
 * Function that creates a single route which handles any workflow execution
 * request and routes to the appropriate workflow function.
 *
 * @param workflowCode - The workflow bundle code containing all the workflow
 * functions at the top level.
 * @returns A function that can be used as a Vercel API route.
 */
export function workflowEntrypoint(workflowCode) {
    const handler = getWorldHandlers().createQueueHandler('__wkf_workflow_', async (message_, metadata) => {
        const { runId, traceCarrier: traceContext, requestedAt, } = WorkflowInvokePayloadSchema.parse(message_);
        // Extract the workflow name from the topic name
        const workflowName = metadata.queueName.slice('__wkf_workflow_'.length);
        const spanLinks = await linkToCurrentContext();
        // Invoke user workflow within the propagated trace context
        return await withTraceContext(traceContext, async () => {
            const world = getWorld();
            return trace(`WORKFLOW ${workflowName}`, { links: spanLinks }, async (span) => {
                span?.setAttributes({
                    ...Attribute.WorkflowName(workflowName),
                    ...Attribute.WorkflowOperation('execute'),
                    ...Attribute.QueueName(metadata.queueName),
                    ...Attribute.QueueMessageId(metadata.messageId),
                    ...getQueueOverhead({ requestedAt }),
                });
                // TODO: validate `workflowName` exists before consuming message?
                span?.setAttributes({
                    ...Attribute.WorkflowRunId(runId),
                    ...Attribute.WorkflowTracePropagated(!!traceContext),
                });
                let workflowStartedAt = -1;
                try {
                    let workflowRun = await world.runs.get(runId);
                    if (workflowRun.status === 'pending') {
                        workflowRun = await world.runs.update(runId, {
                            // This sets the `startedAt` timestamp at the database level
                            status: 'running',
                        });
                    }
                    // At this point, the workflow is "running" and `startedAt` should
                    // definitely be set.
                    if (!workflowRun.startedAt) {
                        throw new Error(`Workflow run "${runId}" has no "startedAt" timestamp`);
                    }
                    workflowStartedAt = +workflowRun.startedAt;
                    span?.setAttributes({
                        ...Attribute.WorkflowRunStatus(workflowRun.status),
                        ...Attribute.WorkflowStartedAt(workflowStartedAt),
                    });
                    if (workflowRun.status !== 'running') {
                        // Workflow has already completed or failed, so we can skip it
                        console.warn(`Workflow "${runId}" has status "${workflowRun.status}", skipping`);
                        // TODO: for `cancel`, we actually want to propagate a WorkflowCancelled event
                        // inside the workflow context so the user can gracefully exit. this is SIGTERM
                        // TODO: furthermore, there should be a timeout or a way to force cancel SIGKILL
                        // so that we actually exit here without replaying the workflow at all, in the case
                        // the replaying the workflow is itself failing.
                        return;
                    }
                    // Load all events into memory before running
                    const events = await getAllWorkflowRunEvents(workflowRun.runId);
                    // Check for any elapsed waits and create wait_completed events
                    const now = Date.now();
                    for (const event of events) {
                        if (event.eventType === 'wait_created') {
                            const resumeAt = event.eventData.resumeAt;
                            const hasCompleted = events.some((e) => e.eventType === 'wait_completed' &&
                                e.correlationId === event.correlationId);
                            // If wait has elapsed and hasn't been completed yet
                            if (!hasCompleted && now >= resumeAt.getTime()) {
                                const completedEvent = await world.events.create(runId, {
                                    eventType: 'wait_completed',
                                    correlationId: event.correlationId,
                                });
                                // Add the event to the events array so the workflow can see it
                                events.push(completedEvent);
                            }
                        }
                    }
                    const result = await runWorkflow(workflowCode, workflowRun, events);
                    // Update the workflow run with the result
                    await world.runs.update(runId, {
                        status: 'completed',
                        output: result,
                    });
                    span?.setAttributes({
                        ...Attribute.WorkflowRunStatus('completed'),
                        ...Attribute.WorkflowEventsCount(events.length),
                    });
                }
                catch (err) {
                    if (WorkflowSuspension.is(err)) {
                        const suspensionMessage = buildWorkflowSuspensionMessage(runId, err.stepCount, err.hookCount, err.waitCount);
                        if (suspensionMessage) {
                            runtimeLogger.debug(suspensionMessage);
                        }
                        const result = await handleSuspension({
                            suspension: err,
                            world,
                            runId,
                            workflowName,
                            workflowStartedAt,
                            span,
                        });
                        if (result.timeoutSeconds !== undefined) {
                            return { timeoutSeconds: result.timeoutSeconds };
                        }
                    }
                    else {
                        const errorName = getErrorName(err);
                        const errorMessage = err instanceof Error ? err.message : String(err);
                        let errorStack = getErrorStack(err);
                        // Remap error stack using source maps to show original source locations
                        if (errorStack) {
                            const parsedName = parseWorkflowName(workflowName);
                            const filename = parsedName?.path || workflowName;
                            errorStack = remapErrorStack(errorStack, filename, workflowCode);
                        }
                        console.error(`${errorName} while running "${runId}" workflow:\n\n${errorStack}`);
                        await world.runs.update(runId, {
                            status: 'failed',
                            error: {
                                message: errorMessage,
                                stack: errorStack,
                                // TODO: include error codes when we define them
                            },
                        });
                        span?.setAttributes({
                            ...Attribute.WorkflowRunStatus('failed'),
                            ...Attribute.WorkflowErrorName(errorName),
                            ...Attribute.WorkflowErrorMessage(String(err)),
                        });
                    }
                }
            }); // End withTraceContext
        });
    });
    return withHealthCheck(handler);
}
// this is a no-op placeholder as the client is
// expecting this to be present but we aren't actually using it
export function runStep() { }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9ydW50aW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx5QkFBeUIsRUFDekIsc0JBQXNCLEVBQ3RCLDRCQUE0QixHQUM3QixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFFTCwyQkFBMkIsR0FJNUIsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDakQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLGdCQUFnQixFQUNoQixlQUFlLEdBQ2hCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDbkUsT0FBTyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRWhFLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsMEJBQTBCLEdBQzNCLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2xELE9BQU8sS0FBSyxTQUFTLE1BQU0scUNBQXFDLENBQUM7QUFDakUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9FLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3pELE9BQU8sRUFDTCw4QkFBOEIsRUFDOUIsc0JBQXNCLEdBQ3ZCLE1BQU0sV0FBVyxDQUFDO0FBQ25CLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHNUMsT0FBTyxFQUFFLGtCQUFrQixF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