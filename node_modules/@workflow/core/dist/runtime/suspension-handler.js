import { waitUntil } from '@vercel/functions';
import { WorkflowAPIError } from '@workflow/errors';
import { dehydrateStepArguments } from '../serialization.js';
import * as Attribute from '../telemetry/semantic-conventions.js';
import { serializeTraceCarrier } from '../telemetry.js';
import { queueMessage } from './helpers.js';
/**
 * Processes a single hook by creating it in the database and event log.
 */
async function processHook({ queueItem, world, runId, global, }) {
    try {
        // Create hook in database
        const hookMetadata = typeof queueItem.metadata === 'undefined'
            ? undefined
            : dehydrateStepArguments(queueItem.metadata, global);
        await world.hooks.create(runId, {
            hookId: queueItem.correlationId,
            token: queueItem.token,
            metadata: hookMetadata,
        });
        // Create hook_created event in event log
        await world.events.create(runId, {
            eventType: 'hook_created',
            correlationId: queueItem.correlationId,
        });
    }
    catch (err) {
        if (WorkflowAPIError.is(err)) {
            if (err.status === 409) {
                // Hook already exists (duplicate hook_id constraint), so we can skip it
                console.warn(`Hook with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err.message}`);
                return;
            }
            else if (err.status === 410) {
                // Workflow has already completed, so no-op
                console.warn(`Workflow run "${runId}" has already completed, skipping hook "${queueItem.correlationId}": ${err.message}`);
                return;
            }
        }
        throw err;
    }
}
/**
 * Processes a single step by creating it in the database and queueing execution.
 */
async function processStep({ queueItem, world, runId, workflowName, workflowStartedAt, global, }) {
    const ops = [];
    const dehydratedInput = dehydrateStepArguments({
        args: queueItem.args,
        closureVars: queueItem.closureVars,
    }, global);
    try {
        const step = await world.steps.create(runId, {
            stepId: queueItem.correlationId,
            stepName: queueItem.stepName,
            input: dehydratedInput,
        });
        waitUntil(Promise.all(ops).catch((opErr) => {
            // Ignore expected client disconnect errors (e.g., browser refresh during streaming)
            const isAbortError = opErr?.name === 'AbortError' || opErr?.name === 'ResponseAborted';
            if (!isAbortError)
                throw opErr;
        }));
        await queueMessage(world, `__wkf_step_${queueItem.stepName}`, {
            workflowName,
            workflowRunId: runId,
            workflowStartedAt,
            stepId: step.stepId,
            traceCarrier: await serializeTraceCarrier(),
            requestedAt: new Date(),
        }, {
            idempotencyKey: queueItem.correlationId,
        });
    }
    catch (err) {
        if (WorkflowAPIError.is(err) && err.status === 409) {
            // Step already exists, so we can skip it
            console.warn(`Step "${queueItem.stepName}" with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err.message}`);
            return;
        }
        throw err;
    }
}
/**
 * Processes a single wait by creating the event and calculating timeout.
 * @returns The timeout in seconds, or null if the wait already exists.
 */
async function processWait({ queueItem, world, runId, }) {
    try {
        // Only create wait_created event if it hasn't been created yet
        if (!queueItem.hasCreatedEvent) {
            await world.events.create(runId, {
                eventType: 'wait_created',
                correlationId: queueItem.correlationId,
                eventData: {
                    resumeAt: queueItem.resumeAt,
                },
            });
        }
        // Calculate how long to wait before resuming
        const now = Date.now();
        const resumeAtMs = queueItem.resumeAt.getTime();
        const delayMs = Math.max(1000, resumeAtMs - now);
        return Math.ceil(delayMs / 1000);
    }
    catch (err) {
        if (WorkflowAPIError.is(err) && err.status === 409) {
            // Wait already exists, so we can skip it
            console.warn(`Wait with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err.message}`);
            return null;
        }
        throw err;
    }
}
/**
 * Handles a workflow suspension by processing all pending operations (hooks, steps, waits).
 * Hooks are processed first to prevent race conditions, then steps and waits in parallel.
 */
export async function handleSuspension({ suspension, world, runId, workflowName, workflowStartedAt, span, }) {
    // Separate queue items by type for parallel processing
    const stepItems = suspension.steps.filter((item) => item.type === 'step');
    const hookItems = suspension.steps.filter((item) => item.type === 'hook');
    const waitItems = suspension.steps.filter((item) => item.type === 'wait');
    // Process all hooks first to prevent race conditions
    await Promise.all(hookItems.map((queueItem) => processHook({
        queueItem,
        world,
        runId,
        global: suspension.globalThis,
    })));
    // Then process steps and waits in parallel
    const [, waitTimeouts] = await Promise.all([
        Promise.all(stepItems.map((queueItem) => processStep({
            queueItem,
            world,
            runId,
            workflowName,
            workflowStartedAt,
            global: suspension.globalThis,
        }))),
        Promise.all(waitItems.map((queueItem) => processWait({
            queueItem,
            world,
            runId,
        }))),
    ]);
    // Find minimum timeout from waits
    const minTimeoutSeconds = waitTimeouts.reduce((min, timeout) => {
        if (timeout === null)
            return min;
        if (min === null)
            return timeout;
        return Math.min(min, timeout);
    }, null);
    span?.setAttributes({
        ...Attribute.WorkflowRunStatus('workflow_suspended'),
        ...Attribute.WorkflowStepsCreated(stepItems.length),
        ...Attribute.WorkflowHooksCreated(hookItems.length),
        ...Attribute.WorkflowWaitsCreated(waitItems.length),
    });
    // If we encountered any waits, return the minimum timeout
    if (minTimeoutSeconds !== null) {
        return { timeoutSeconds: minTimeoutSeconds };
    }
    return {};
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VzcGVuc2lvbi1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bnRpbWUvc3VzcGVuc2lvbi1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQVNwRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM3RCxPQUFPLEtBQUssU0FBUyxNQUFNLHNDQUFzQyxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFzQjVDOztHQUVHO0FBQ0gsS0FBSyxVQUFVLFdBQVcsQ0FBQyxFQUN6QixTQUFTLEVBQ1QsS0FBSyxFQUNMLEtBQUssRUFDTCxNQUFNLEdBQ1k7SUFDbEIsSUFBSSxDQUFDO1FBQ0gsMEJBQTBCO1FBQzFCLE1BQU0sWUFBWSxHQUNoQixPQUFPLFNBQVMsQ0FBQyxRQUFRLEtBQUssV0FBVztZQUN2QyxDQUFDLENBQUMsU0FBUztZQUNYLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pELE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQzlCLE1BQU0sRUFBRSxTQUFTLENBQUMsYUFBYTtZQUMvQixLQUFLLEVBQUUsU0FBUyxDQUFDLEtBQUs7WUFDdEIsUUFBUSxFQUFFLFlBQVk7U0FDdkIsQ0FBQyxDQUFDO1FBRUgseUNBQXlDO1FBQ3pDLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQy9CLFNBQVMsRUFBRSxjQUFjO1lBQ3pCLGFBQWEsRUFBRSxTQUFTLENBQUMs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