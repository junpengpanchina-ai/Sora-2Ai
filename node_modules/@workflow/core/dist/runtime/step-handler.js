import { waitUntil } from '@vercel/functions';
import { FatalError, RetryableError, WorkflowAPIError, WorkflowRuntimeError, } from '@workflow/errors';
import { getPort } from '@workflow/utils/get-port';
import { StepInvokePayloadSchema } from '@workflow/world';
import { runtimeLogger } from '../logger.js';
import { getStepFunction } from '../private.js';
import { dehydrateStepReturnValue, hydrateStepArguments, } from '../serialization.js';
import { contextStorage } from '../step/context-storage.js';
import * as Attribute from '../telemetry/semantic-conventions.js';
import { getSpanKind, linkToCurrentContext, serializeTraceCarrier, trace, withTraceContext, } from '../telemetry.js';
import { getErrorName, getErrorStack } from '../types.js';
import { getQueueOverhead, queueMessage, withHealthCheck } from './helpers.js';
import { getWorld, getWorldHandlers } from './world.js';
const DEFAULT_STEP_MAX_RETRIES = 3;
const stepHandler = getWorldHandlers().createQueueHandler('__wkf_step_', async (message_, metadata) => {
    const { workflowName, workflowRunId, workflowStartedAt, stepId, traceCarrier: traceContext, requestedAt, } = StepInvokePayloadSchema.parse(message_);
    const spanLinks = await linkToCurrentContext();
    // Execute step within the propagated trace context
    return await withTraceContext(traceContext, async () => {
        // Extract the step name from the topic name
        const stepName = metadata.queueName.slice('__wkf_step_'.length);
        const world = getWorld();
        // Get the port early to avoid async operations during step execution
        const port = await getPort();
        return trace(`STEP ${stepName}`, { kind: await getSpanKind('CONSUMER'), links: spanLinks }, async (span) => {
            span?.setAttributes({
                ...Attribute.StepName(stepName),
                ...Attribute.StepAttempt(metadata.attempt),
                ...Attribute.QueueName(metadata.queueName),
                ...Attribute.QueueMessageId(metadata.messageId),
                ...getQueueOverhead({ requestedAt }),
            });
            const stepFn = getStepFunction(stepName);
            if (!stepFn) {
                throw new Error(`Step "${stepName}" not found`);
            }
            if (typeof stepFn !== 'function') {
                throw new Error(`Step "${stepName}" is not a function (got ${typeof stepFn})`);
            }
            const maxRetries = stepFn.maxRetries ?? DEFAULT_STEP_MAX_RETRIES;
            span?.setAttributes({
                ...Attribute.WorkflowName(workflowName),
                ...Attribute.WorkflowRunId(workflowRunId),
                ...Attribute.StepId(stepId),
                ...Attribute.StepMaxRetries(maxRetries),
                ...Attribute.StepTracePropagated(!!traceContext),
            });
            let step = await world.steps.get(workflowRunId, stepId);
            runtimeLogger.debug('Step execution details', {
                stepName,
                stepId: step.stepId,
                status: step.status,
                attempt: step.attempt,
            });
            span?.setAttributes({
                ...Attribute.StepStatus(step.status),
            });
            // Check if the step has a `retryAfter` timestamp that hasn't been reached yet
            const now = Date.now();
            if (step.retryAfter && step.retryAfter.getTime() > now) {
                const timeoutSeconds = Math.ceil((step.retryAfter.getTime() - now) / 1000);
                span?.setAttributes({
                    ...Attribute.StepRetryTimeoutSeconds(timeoutSeconds),
                });
                runtimeLogger.debug('Step retryAfter timestamp not yet reached', {
                    stepName,
                    stepId: step.stepId,
                    retryAfter: step.retryAfter,
                    timeoutSeconds,
                });
                return { timeoutSeconds };
            }
            let result;
            const attempt = step.attempt + 1;
            // Check max retries FIRST before any state changes.
            // This handles edge cases where the step handler is invoked after max retries have been exceeded
            // (e.g., when the step repeatedly times out or fails before reaching the catch handler at line 822).
            // Without this check, the step would retry forever.
            if (attempt > maxRetries) {
                const errorMessage = `Step "${stepName}" exceeded max retries (${attempt} attempts)`;
                console.error(`[Workflows] "${workflowRunId}" - ${errorMessage}`);
                // Update step status first (idempotent), then create event
                await world.steps.update(workflowRunId, stepId, {
                    status: 'failed',
                    error: {
                        message: errorMessage,
                        stack: undefined,
                    },
                });
                await world.events.create(workflowRunId, {
                    eventType: 'step_failed',
                    correlationId: stepId,
                    eventData: {
                        error: errorMessage,
                        fatal: true,
                    },
                });
                span?.setAttributes({
                    ...Attribute.StepStatus('failed'),
                    ...Attribute.StepRetryExhausted(true),
                });
                // Re-invoke the workflow to handle the failed step
                await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                    runId: workflowRunId,
                    traceCarrier: await serializeTraceCarrier(),
                    requestedAt: new Date(),
                });
                return;
            }
            try {
                if (!['pending', 'running'].includes(step.status)) {
                    // We should only be running the step if it's either
                    // a) pending - initial state, or state set on re-try
                    // b) running - if a step fails mid-execution, like a function timeout
                    // otherwise, the step has been invoked erroneously
                    console.error(`[Workflows] "${workflowRunId}" - Step invoked erroneously, expected status "pending" or "running", got "${step.status}" instead, skipping execution`);
                    span?.setAttributes({
                        ...Attribute.StepSkipped(true),
                        ...Attribute.StepSkipReason(step.status),
                    });
                    // There's a chance that a step terminates correctly, but the underlying process
                    // fails or gets killed before the stepEntrypoint has a chance to re-enqueue the run.
                    // The queue lease expires and stepEntrypoint again, which leads us here, so
                    // we optimistically re-enqueue the workflow if the step is in a terminal state,
                    // under the assumption that this edge case happened.
                    // Until we move to atomic entity/event updates (World V2), there _could_ be an edge case
                    // where the we execute this code based on the `step` entity status, but the runtime
                    // failed to create the `step_completed` event (due to failing between step and event update),
                    // in which case, this might lead to an infinite loop.
                    // https://vercel.slack.com/archives/C09125LC4AX/p1765313809066679
                    const isTerminalStep = [
                        'completed',
                        'failed',
                        'cancelled',
                    ].includes(step.status);
                    if (isTerminalStep) {
                        await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                            runId: workflowRunId,
                            traceCarrier: await serializeTraceCarrier(),
                            requestedAt: new Date(),
                        });
                    }
                    return;
                }
                await world.events.create(workflowRunId, {
                    eventType: 'step_started', // TODO: Replace with 'step_retrying'
                    correlationId: stepId,
                });
                step = await world.steps.update(workflowRunId, stepId, {
                    attempt,
                    status: 'running',
                });
                if (!step.startedAt) {
                    throw new WorkflowRuntimeError(`Step "${stepId}" has no "startedAt" timestamp`);
                }
                // Hydrate the step input arguments and closure variables
                const ops = [];
                const hydratedInput = hydrateStepArguments(step.input, ops, workflowRunId);
                const args = hydratedInput.args;
                span?.setAttributes({
                    ...Attribute.StepArgumentsCount(args.length),
                });
                result = await contextStorage.run({
                    stepMetadata: {
                        stepId,
                        stepStartedAt: new Date(+step.startedAt),
                        attempt,
                    },
                    workflowMetadata: {
                        workflowRunId,
                        workflowStartedAt: new Date(+workflowStartedAt),
                        // TODO: there should be a getUrl method on the world interface itself. This
                        // solution only works for vercel + local worlds.
                        url: process.env.VERCEL_URL
                            ? `https://${process.env.VERCEL_URL}`
                            : `http://localhost:${port ?? 3000}`,
                    },
                    ops,
                    closureVars: hydratedInput.closureVars,
                }, () => stepFn.apply(null, args));
                // NOTE: None of the code from this point is guaranteed to run
                // Since the step might fail or cause a function timeout and the process might be SIGKILL'd
                // The workflow runtime must be resilient to the below code not executing on a failed step
                result = dehydrateStepReturnValue(result, ops, workflowRunId);
                waitUntil(Promise.all(ops).catch((err) => {
                    // Ignore expected client disconnect errors (e.g., browser refresh during streaming)
                    const isAbortError = err?.name === 'AbortError' || err?.name === 'ResponseAborted';
                    if (!isAbortError)
                        throw err;
                }));
                // Mark the step as completed first. This order is important. If a concurrent
                // execution marked the step as complete, this request should throw, and
                // this prevent the step_completed event in the event log
                // TODO: this should really be atomic and handled by the world
                await world.steps.update(workflowRunId, stepId, {
                    status: 'completed',
                    output: result,
                });
                // Then, append the event log with the step result
                await world.events.create(workflowRunId, {
                    eventType: 'step_completed',
                    correlationId: stepId,
                    eventData: {
                        result: result,
                    },
                });
                span?.setAttributes({
                    ...Attribute.StepStatus('completed'),
                    ...Attribute.StepResultType(typeof result),
                });
            }
            catch (err) {
                span?.setAttributes({
                    ...Attribute.StepErrorName(getErrorName(err)),
                    ...Attribute.StepErrorMessage(String(err)),
                });
                if (WorkflowAPIError.is(err)) {
                    if (err.status === 410) {
                        // Workflow has already completed, so no-op
                        console.warn(`Workflow run "${workflowRunId}" has already completed, skipping step "${stepId}": ${err.message}`);
                        return;
                    }
                }
                if (FatalError.is(err)) {
                    const errorStack = getErrorStack(err);
                    const stackLines = errorStack.split('\n').slice(0, 4);
                    console.error(`[Workflows] "${workflowRunId}" - Encountered \`FatalError\` while executing step "${stepName}":\n  > ${stackLines.join('\n    > ')}\n\nBubbling up error to parent workflow`);
                    // Fatal error - store the error in the event log and re-invoke the workflow
                    await world.events.create(workflowRunId, {
                        eventType: 'step_failed',
                        correlationId: stepId,
                        eventData: {
                            error: String(err),
                            stack: errorStack,
                            fatal: true,
                        },
                    });
                    await world.steps.update(workflowRunId, stepId, {
                        status: 'failed',
                        error: {
                            message: err.message || String(err),
                            stack: errorStack,
                            // TODO: include error codes when we define them
                        },
                    });
                    span?.setAttributes({
                        ...Attribute.StepStatus('failed'),
                        ...Attribute.StepFatalError(true),
                    });
                }
                else {
                    const maxRetries = stepFn.maxRetries ?? DEFAULT_STEP_MAX_RETRIES;
                    span?.setAttributes({
                        ...Attribute.StepAttempt(attempt),
                        ...Attribute.StepMaxRetries(maxRetries),
                    });
                    if (attempt > maxRetries) {
                        // Max retries reached
                        const errorStack = getErrorStack(err);
                        const stackLines = errorStack.split('\n').slice(0, 4);
                        console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):\n  > ${stackLines.join('\n    > ')}\n\n  Max retries reached\n  Bubbling error to parent workflow`);
                        const errorMessage = `Step "${stepName}" failed after max retries: ${String(err)}`;
                        await world.events.create(workflowRunId, {
                            eventType: 'step_failed',
                            correlationId: stepId,
                            eventData: {
                                error: errorMessage,
                                stack: errorStack,
                                fatal: true,
                            },
                        });
                        await world.steps.update(workflowRunId, stepId, {
                            status: 'failed',
                            error: {
                                message: errorMessage,
                                stack: errorStack,
                            },
                        });
                        span?.setAttributes({
                            ...Attribute.StepStatus('failed'),
                            ...Attribute.StepRetryExhausted(true),
                        });
                    }
                    else {
                        // Not at max retries yet - log as a retryable error
                        if (RetryableError.is(err)) {
                            console.warn(`[Workflows] "${workflowRunId}" - Encountered \`RetryableError\` while executing step "${stepName}" (attempt ${attempt}):\n  > ${String(err.message)}\n\n  This step has failed but will be retried`);
                        }
                        else {
                            const stackLines = getErrorStack(err).split('\n').slice(0, 4);
                            console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):\n  > ${stackLines.join('\n    > ')}\n\n  This step has failed but will be retried`);
                        }
                        await world.events.create(workflowRunId, {
                            eventType: 'step_failed',
                            correlationId: stepId,
                            eventData: {
                                error: String(err),
                                stack: getErrorStack(err),
                            },
                        });
                        await world.steps.update(workflowRunId, stepId, {
                            status: 'pending', // TODO: Should be "retrying" once we have that status
                            ...(RetryableError.is(err) && {
                                retryAfter: err.retryAfter,
                            }),
                        });
                        const timeoutSeconds = Math.max(1, RetryableError.is(err)
                            ? Math.ceil((+err.retryAfter.getTime() - Date.now()) / 1000)
                            : 1);
                        span?.setAttributes({
                            ...Attribute.StepRetryTimeoutSeconds(timeoutSeconds),
                            ...Attribute.StepRetryWillRetry(true),
                        });
                        // It's a retryable error - so have the queue keep the message visible
                        // so that it gets retried.
                        return { timeoutSeconds };
                    }
                }
            }
            await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                runId: workflowRunId,
                traceCarrier: await serializeTraceCarrier(),
                requestedAt: new Date(),
            });
        });
    });
});
/**
 * A single route that handles any step execution request and routes to the
 * appropriate step function. We may eventually want to create different bundles
 * for each step, this is temporary.
 */
export const stepEntrypoint = 
/* @__PURE__ */ withHealthCheck(stepHandler);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcC1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bnRpbWUvc3RlcC1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsb0JBQW9CLEdBQ3JCLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ25ELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzFELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVoRCxPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLG9CQUFvQixHQUNyQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM1RCxPQUFPLEtBQUssU0FBUyxNQUFNLHNDQUFzQyxDQUFDO0FBQ2xFLE9BQU8sRUFDTCxXQUFXLEVBQ1gsb0JBQW9CLEVBQ3BCLHFCQUFxQixFQUNyQixLQUFLLEVBQ0wsZ0JBQWdCLEdBQ2pCLE1BQU0saUJBQWlCLENBQUM7QUFDekIsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDMUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDL0UsT0FBTyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUV4RCxNQUFNLHdCQUF3QixHQUFHLENBQUMsQ0FBQztBQUVuQyxNQUFNLFdBQVcsR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLGtCQUFrQixDQUN2RCxh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