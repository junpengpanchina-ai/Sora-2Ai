import { waitUntil } from '@vercel/functions';
/**
 * Builds a workflow suspension log message based on the counts of steps, hooks, and waits.
 * @param runId - The workflow run ID
 * @param stepCount - Number of steps to be enqueued
 * @param hookCount - Number of hooks to be enqueued
 * @param waitCount - Number of waits to be enqueued
 * @returns The formatted log message or null if all counts are 0
 */
export function buildWorkflowSuspensionMessage(runId, stepCount, hookCount, waitCount) {
    if (stepCount === 0 && hookCount === 0 && waitCount === 0) {
        return null;
    }
    const parts = [];
    if (stepCount > 0) {
        parts.push(`${stepCount} ${stepCount === 1 ? 'step' : 'steps'}`);
    }
    if (hookCount > 0) {
        parts.push(`${hookCount} ${hookCount === 1 ? 'hook' : 'hooks'}`);
    }
    if (waitCount > 0) {
        parts.push(`${waitCount} ${waitCount === 1 ? 'timer' : 'timers'}`);
    }
    const resumeMsgParts = [];
    if (stepCount > 0) {
        resumeMsgParts.push('steps are completed');
    }
    if (hookCount > 0) {
        resumeMsgParts.push('hooks are received');
    }
    if (waitCount > 0) {
        resumeMsgParts.push('timers have elapsed');
    }
    const resumeMsg = resumeMsgParts.join(' and ');
    return `[Workflows] "${runId}" - ${parts.join(' and ')} to be enqueued\n  Workflow will suspend and resume when ${resumeMsg}`;
}
/**
 * Generates a stream ID for a workflow run.
 * User-defined streams include a "user" segment for isolation from future system-defined streams.
 * Namespaces are base64-encoded to handle characters not allowed in Redis key names.
 *
 * @param runId - The workflow run ID
 * @param namespace - Optional namespace for the stream
 * @returns The stream ID in format: `strm_{ULID}_user_{base64(namespace)?}`
 */
export function getWorkflowRunStreamId(runId, namespace) {
    const streamId = `${runId.replace('wrun_', 'strm_')}_user`;
    if (!namespace) {
        return streamId;
    }
    // Base64 encode the namespace to handle special characters that may not be allowed in Redis keys
    const encodedNamespace = Buffer.from(namespace, 'utf-8').toString('base64url');
    return `${streamId}_${encodedNamespace}`;
}
/**
 * A small wrapper around `waitUntil` that also returns
 * the result of the awaited promise.
 */
export async function waitedUntil(fn) {
    const result = fn();
    waitUntil(result.catch(() => {
        // Ignore error from the promise being rejected.
        // It's expected that the invoker of `waitedUntil`
        // will handle the error.
    }));
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUU5Qzs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLDhCQUE4QixDQUM1QyxLQUFhLEVBQ2IsU0FBaUIsRUFDakIsU0FBaUIsRUFDakIsU0FBaUI7SUFFakIsSUFBSSxTQUFTLEtBQUssQ0FBQyxJQUFJLFNBQVMsS0FBSyxDQUFDLElBQUksU0FBUyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQzFELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUNqQixJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNsQixLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxJQUFJLFNBQVMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBQ0QsSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsSUFBSSxTQUFTLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUNELElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ2xCLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLElBQUksU0FBUyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRCxNQUFNLGNBQWMsR0FBYSxFQUFFLENBQUM7SUFDcEMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDbEIsY0FBYyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFDRCxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNsQixjQUFjLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUNELElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ2xCLGNBQWMsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBQ0QsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUUvQyxPQUFPLGdCQUFnQixLQUFLLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsNERBQTRELFNBQVMsRUFBRSxDQUFDO0FBQ2hJLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFhLEVBQUUsU0FBa0I7SUFDdEUsTUFBTSxRQUFRLEdBQUcsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzNELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNmLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFDRCxpR0FBaUc7SUFDakcsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQy9ELFdBQVcsQ0FDWixDQUFDO0lBQ0YsT0FBTyxHQUFHLFFBQVEsSUFBSSxnQkFBZ0IsRUFBRSxDQUFDO0FBQzNDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLFdBQVcsQ0FBSSxFQUFvQjtJQUN2RCxNQUFNLE1BQU0sR0FBRyxFQUFFLEVBQUUsQ0FBQztJQUNwQixTQUFTLENBQ1AsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7UUFDaEIsZ0RBQWdEO1FBQ2hELGtEQUFrRDtRQUNsRCx5QkFBeUI7SUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNGLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMifQ==